---
title: "Video Compression"
description: "FFmpeg-based video optimization pipeline for efficient storage and streaming of live performance content."
---

The video compression pipeline optimizes live streams for permanent storage while maintaining quality suitable for replay and NFT preservation. Using FFmpeg, it processes HLS segments into web-compatible MP4 chunks with efficient encoding settings.

## Compression Strategy

### Quality vs. Size Optimization

The system balances three key factors:

- **Visual Quality**: Preserve performance details for NFT value
- **File Size**: Minimize Filecoin storage costs
- **Compatibility**: Ensure broad browser and device support

**Target Specifications**:
- **Container**: MP4 with `faststart` flag for web streaming
- **Video Codec**: H.264 (libx264) for universal compatibility
- **Audio Codec**: AAC at 128kbps for clear speech/music
- **Resolution**: Maintain source resolution (typically 1080p)
- **Frame Rate**: Preserve original frame rate (usually 30fps)

**Encoding Presets**: Three quality levels - High (CRF 23, medium preset, 2000k bitrate), Medium (CRF 26, fast preset, 1000k bitrate), Low (CRF 30, faster preset, 500k bitrate).

## FFmpeg Pipeline

### Segment Concatenation

**Input Processing**: createVideoChunk function combines 10-second HLS segments into 60-second chunks using FFmpeg concat demuxer with libx264 video, AAC audio, CRF 26, and faststart flag.

### Quality Control

**Constant Rate Factor (CRF)**:
CRF provides consistent visual quality across different content types:

- **CRF 18-23**: Near-lossless, suitable for archival
- **CRF 23-28**: High quality, good for distribution
- **CRF 28-32**: Medium quality, smaller files
- **CRF 32+**: Low quality, minimal bandwidth

## Performance Optimization

### Hardware Acceleration

**GPU Encoding** (when available):
```typescript
const hwAccelOptions = {
  nvidia: ['-c:v', 'h264_nvenc', '-preset', 'fast'],
  intel: ['-c:v', 'h264_vaapi', '-vaapi_device', '/dev/dri/renderD128'],
  amd: ['-c:v', 'h264_amf'],
  apple: ['-c:v', 'h264_videotoolbox']
}

function getHardwareEncoder(): string[] {
  const platform = process.platform
  const hasNvidia = checkNvidiaGPU()
  const hasIntelGPU = checkIntelGPU()
  
  if (hasNvidia) return hwAccelOptions.nvidia
  if (platform === 'darwin') return hwAccelOptions.apple
  if (hasIntelGPU) return hwAccelOptions.intel
  
  return [] // Fallback to software encoding
}
```

### CPU Optimization

**Multi-threading**:
```typescript
function calculateOptimalThreads(): number {
  const cpuCores = os.cpus().length
  const memoryGB = os.totalmem() / (1024 * 1024 * 1024)
  
  // Reserve cores for other processes
  const maxThreads = Math.max(1, cpuCores - 2)
  
  // Memory constraint: ~1GB per thread for 1080p
  const memoryLimitedThreads = Math.floor(memoryGB / 1.5)
  
  return Math.min(maxThreads, memoryLimitedThreads, 8)
}

// Apply to FFmpeg command
const threads = calculateOptimalThreads()
ffmpegArgs.push('-threads', threads.toString())
```

### Memory Management

**Streaming Processing**:
```typescript
// Process video in streaming mode to handle large files
const streamingOptions = [
  '-f', 'mp4',
  '-movflags', 'frag_keyframe+empty_moov+faststart',
  '-reset_timestamps', '1',
  '-avoid_negative_ts', 'make_zero'
]
```

## Quality Analysis

### Content-Aware Compression

**Motion Detection**:
```typescript
async function analyzeMotion(segmentPath: string): Promise<number> {
  const analysis = await execFFmpeg([
    '-i', segmentPath,
    '-vf', 'select=gt(scene\\,0.3)',
    '-f', 'null',
    '-'
  ])
  
  // Parse motion vectors from output
  const motionScore = parseMotionAnalysis(analysis.stderr)
  return Math.min(1.0, motionScore / 100)
}
```

## Size Optimization

### File Size Targets

**Storage Cost Considerations**:
```typescript
const storageCostTargets = {
  // Target file sizes for different durations (60s chunks)
  maxSizes: {
    '1080p': 25 * 1024 * 1024,  // 25MB for 60s
    '720p': 15 * 1024 * 1024,   // 15MB for 60s
    '480p': 8 * 1024 * 1024     // 8MB for 60s
  },
  
  // Filecoin cost per GB/year
  storageCostPerGB: 0.10,
  
  // Target: <$1 storage cost per hour of content
  targetCostPerHour: 1.00
}
```

## Related Documentation

- [Storage](/infra/storage) - How compressed chunks integrate with Filecoin storage
- [SRS](/infra/srs) - Source video streams for compression pipeline
- [Retrieval](/infra/retrieval) - How compressed content is delivered to users
